//
// Created by jtian on 4/24/20.
//

#include <bits/stdint-uintn.h>
#include <cuda_runtime.h>

#include <sys/stat.h>
#include <bitset>
#include <cassert>
#include <iostream>
#include <string>
#include <tuple>

#include <stdio.h>

#include "../cuda_error_handling.cuh"
#include "../cuda_mem.cuh"
#include "../huffman_codec.cuh"
#include "../huffman_workflow.cuh"
#include "../timer.hh"
#include "../types.hh"

#include "reduce_move_merge.cuh"
#include "utils.cuh"

using std::cerr;
using std::cout;
using std::endl;
using std::string;

uint32_t dbg_bi = 2;

using ulli = unsigned long long int;

template <typename Input, typename Huff, typename Dict, int Magnitude, int ReductionFactor, int ShuffleFactor>
std::tuple<uint32_t, Huff*, uint32_t*> Encoder(
    Input*      q,
    uint32_t    len,
    Dict*       cb,
    uint32_t    cb_len,
    uint32_t    dummy_nchunk_,
    std::string encoder,
    bool        use_dummylen = false)
{
    auto chunksize = 1 << Magnitude;
    if (use_dummylen) len = dummy_nchunk_ * chunksize;

    auto blockDim = 1 << Magnitude;
    // auto n_chunk  = len / chunksize;  // dividable (from caller)
    auto gridDim = 1 << ShuffleFactor;

    auto d_q     = mem::CreateDeviceSpaceAndMemcpyFromHost(q, len);
    auto d_cb    = mem::CreateDeviceSpaceAndMemcpyFromHost(cb, cb_len);
    auto d_h     = mem::CreateCUDASpace<Huff>(len);
    auto d_hmeta = mem::CreateCUDASpace<uint32_t>(gridDim);  // chunkwise metadata

    auto buff_bytes = chunksize * (sizeof(Huff) + sizeof(int));
    // alternatively,
    // auto buff_bytes = (chunksize / 2 + chunksize / 4) * (sizeof(Huff) + sizeof(int));
    // share memory usage: 1.5 * chunksize * 4 = 6 * chunksize: 6 * 1K = 6K
    // data size: sizeof(uint16_t) * chunksize: 2 * 1024
    // thread number : chunksize >> 3, 128, at max 2* 1024 / 128 = 16 threadblocks on 1 SM

    printf("len:       %d\n", (int)len);
    printf("chunksize: %d\n", (int)chunksize);
    printf("blockDim:  %d\n", (int)blockDim);
    printf("gridDim:   %d\n", (int)gridDim);
    printf("shmem bytes\t%d\t%d blocks EXPECTED on 1 SM (shmem)\n", (int)buff_bytes, int(96 * 1024 / buff_bytes));
    printf("%d should be blocks on 1 SM\n", int(1024 * 2 / blockDim));

    if (encoder == "reduce-shuffle") {
        cout << "reduce-shuffle" << endl;
        ReduceShuffle_fixcodebook<Input, Huff, Dict, Magnitude, ReductionFactor, ShuffleFactor>  //
            <<<gridDim, blockDim, buff_bytes>>>(d_q, len, d_cb, d_h, cb_len, d_hmeta, nullptr, dbg_bi);
        cudaDeviceSynchronize();
    }

    auto h     = mem::CreateHostSpaceAndMemcpyFromDevice(d_h, len);
    auto hmeta = mem::CreateHostSpaceAndMemcpyFromDevice(d_hmeta, gridDim);
    cudaFree(d_q), cudaFree(d_cb), cudaFree(d_h), cudaFree(d_hmeta);

    printf("New Encoder: %s gracefully finished\n", encoder.c_str());
    return {(uint32_t)gridDim, h, hmeta};
}

template <typename Huff>
void check_afterward(
    std::tuple<uint32_t, Huff*, uint32_t*> ne,
    std::tuple<uint32_t, Huff*, uint32_t*> oe,
    unsigned int                           len,
    double                                 avg_bw,
    unsigned int                           ChunkSize,
    int                                    override_blks_check = 0)
{
    // depack results
    auto ne_nchunk = std::get<0>(ne);
    auto ne_h      = std::get<1>(ne);
    auto ne_hmeta  = std::get<2>(ne);
    auto oe_nchunk = std::get<0>(oe);
    auto oe_h      = std::get<1>(oe);
    auto oe_hmeta  = std::get<2>(oe);

    if (ne_nchunk != oe_nchunk) {
        cerr << "new encoder nchunk != old enc nchunk" << endl;
        exit(1);
    }

    auto all_meta_equal = true;
    for (auto i = 0; i < ne_nchunk; i++)
        if (ne_hmeta[i] != oe_hmeta[i])
            cout << "chunk " << i << ": ne_hmeta != oe_hmeta" << endl, all_meta_equal = false;

    if (all_meta_equal) cout << "all meta equal for ne and oe" << endl;

    auto count_bad_chunks = 0, count_bad_uint32 = 0;
    auto num_check_blk = ne_nchunk;
    num_check_blk      = override_blks_check == 0 ? ne_nchunk : override_blks_check;

    auto count = 0;

    for (auto i = 0; i < ne_nchunk; i++) {
        for (auto j = 0; j < (ne_hmeta[i] - 1) / (sizeof(Huff) * 8) + 1; j++) {
            auto idx = ChunkSize * i + j;
            if (ne_h[idx] != oe_h[idx]) {
                cout << "hmeta=" << ne_hmeta[i] << " block " << i << " dtype " << j << endl;
                cout << bitset<32>(ne_h[idx]) << "\t(new enc)\n" << bitset<32>(oe_h[idx]) << "\t(old enc)" << endl;
                for (auto ii = 0; ii < sizeof(Huff) * 8; ii++) {
                    auto ne_bit = (ne_h[idx] >> (sizeof(Huff) * 8 - 1 - ii)) & 0x1u;
                    auto oe_bit = (oe_h[idx] >> (sizeof(Huff) * 8 - 1 - ii)) & 0x1u;
                    cout << (ne_bit != oe_bit ? "^" : " ");
                }
                cout << endl, count++;
            }
        }
        if (count != 0) { count_bad_uint32 += count, count_bad_chunks++; }
    }

    if (count != 0) { cout << count << " dtypes are affected." << endl; }
    cout << "# bad chunks: " << count_bad_chunks << " out of " << num_check_blk << endl;
    cout << "# bad uint32: " << count_bad_uint32 << " out of " << static_cast<int>(len * avg_bw / 32) << endl;

    delete[] ne_h, ne_hmeta, oe_h, oe_hmeta;
}

template <typename Input, typename Huff, typename Dict, unsigned int Magnitude, unsigned int ReductionFactor>
void exp_wrapper(Input* q, unsigned int len, Dict* cb, unsigned int cb_len, unsigned int dummy_nchunk, double avg_bw)
{
    std::tuple<uint32_t, Huff*, uint32_t*> ne1;
    // std::tuple<uint32_t, Huff*, uint32_t*> ne2, ne3, ne_dryrun;
    // std::tuple<uint32_t, Huff*, uint32_t*> oe;

    const auto ShuffleFactor = Magnitude - ReductionFactor;

    cout << log_info << "Magnitude=" << Magnitude << "\tReductionFactor=" << ReductionFactor
         << "\tShuffleFactor=" << ShuffleFactor << endl;

    // ne_dryrun = Encoder<Input, Huff, Magnitude, ReductionFactor, ShuffleFactor>          // reduce to find violating
    //     (q, len, cb, cb_len, dummy_nchunk, "dryrun-find-violating", dummy_nchunk != 0);  //
    ne1 = Encoder<Input, Huff, Dict, Magnitude, ReductionFactor, ShuffleFactor>   // reduce shuffle
        (q, len, cb, cb_len, dummy_nchunk, "reduce-shuffle", dummy_nchunk != 0);  //
    // ne2 = Encoder<Input, Huff, Magnitude, ReductionFactor, ShuffleFactor>                // prefix-sum only
    //     (q, len, cb, cb_len, dummy_nchunk, "prefixsum-only", dummy_nchunk != 0);         //
    // ne3 = Encoder<Input, Huff, Magnitude, ReductionFactor, ShuffleFactor>                // reduce + prefix-sum
    //     (q, len, cb, cb_len, dummy_nchunk, "reduce-prefixsum", dummy_nchunk != 0);       //
    // oe = Encoder<Input, Huff, Magnitude, ReductionFactor, ShuffleFactor>                 // cusz-encoder omp-like
    //     (q, len, cb, cb_len, dummy_nchunk, "cusz-enc", dummy_nchunk != 0);

    // const auto ChunkSize     = 1 << Magnitude;
    // check_afterward(ne1, oe, len, avg_bw, ChunkSize, /* some predicate*/ 0);
}

template <typename Input, typename Huff, typename Dict>
void submain(int argc, char** argv)
{
    string   f_indata, f_cb, dtype, dryrun;
    uint32_t dummy_nchunk = 0;
    uint32_t cb_len, len;
    uint32_t threashold_bw = 5;

    if (argc == 2) {
        string tmp(argv[1]);

        if (tmp == "--demo") {
            f_indata = string("data/baryon_density.dat.b16");
            dtype    = string("uint16");
            len      = 512 * 512 * 512;
            f_cb     = string("data/baryon_density.dat.dict");
            cb_len   = 1024;
            cout << "./huffre <input data> <dtype> <len> <codebook> <cb size> <threshold bw>\nusing default: "
                 << f_indata << "\t" << f_cb << endl;
            cout << log_info << "running demo instead" << endl;
            goto execute_demo;
        }
    }
    else if (argc < 8) {
        cout << "./huffre <input data> <dtype> <len> <codebook> <cb size> <threshold bw>" << endl;
        exit(1);
    }
    else if (argc == 7) {
        f_indata      = string(argv[1]);
        dtype         = string(argv[2]);
        len           = atoi(argv[3]);
        f_cb          = string(argv[4]);
        cb_len        = atoi(argv[5]);
        threashold_bw = atoi(argv[6]);  // deprecated
    }
    else if (argc == 8) {
        f_indata      = string(argv[1]);
        dtype         = string(argv[2]);
        len           = atoi(argv[3]);
        f_cb          = string(argv[4]);
        cb_len        = atoi(argv[5]);
        threashold_bw = atoi(argv[6]);  // deprecated
        dryrun        = string(argv[7]);
    }

execute_demo:

    cout << log_info << "using uint" << sizeof(Input) * 8 << " as input data type" << endl;

    cout << log_info << "codebook size\t" << cb_len << endl;
    // cudaDeviceReset();

    auto q  = io::ReadBinaryFile<Input>(f_indata, len);
    auto cb = io::ReadBinaryFile<Dict>(f_cb, cb_len);

    // for (auto i = 0; i < cb_len; i++) {  //
    //     cout << i << "\t" << get_symlen(cb[i]) << "\t" << bitset<32>(cb[i]) << endl;
    // }

    double avg_bw, entropy;
    double avg_bw_post, entropy_post;
    double avg_bw_decision;

    {
        cout << log_info << "before filtering out: " << endl;
        std::tie(avg_bw, entropy) = get_avgbw_entropy<Input, Dict>(q, len, cb, cb_len);

        // filter_out(q, len, cb, cb_len, threashold_bw);  // prepare for extra outliers

        cout << endl;
        cout << log_info << "after filtering out: " << endl;
        std::tie(avg_bw_post, entropy_post) = get_avgbw_entropy<Input, Dict>(q, len, cb, cb_len);

        avg_bw_decision = max(avg_bw, avg_bw_post);
    }

    dbg_bi               = 0;   // debug only
    const auto Magnitude = 10;  // 1 << 10, 1024 point per chunk
    const auto ChunkSize = 1 << Magnitude;

    len = len / ChunkSize * ChunkSize;  // for now

    ////////////////////////////////////////////////////////////////////////////////
    if (std::is_same<Huff, uint32_t>::value) {
        cout << "choosing uint32 type" << endl;
        if (avg_bw_decision < 2) {
            const auto ReductionFactor = 4;
            exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
                q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        }
        // else if (avg_bw_decision >= 2 and avg_bw_decision < 4) {
        //     const auto ReductionFactor = 3;
        //     exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
        //         q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        // }
        // else if (avg_bw_decision >= 4 and avg_bw_decision < 8) {
        //     const auto ReductionFactor = 2;
        //     exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
        //         q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        // }
        // else if (avg_bw_decision >= 8) {
        //     const auto ReductionFactor = 1;
        //     exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
        //         q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        // }
    }
    else if (std::is_same<Huff, unsigned long long>::value) {
        cout << "choosing ull type" << endl;
        if (avg_bw_decision < 2) {
            const auto ReductionFactor = 5;
            exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
                q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        }
        // else if (avg_bw_decision >= 2 and avg_bw_decision < 4) {
        //     const auto ReductionFactor = 4;
        //     exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
        //         q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        // }
        // else if (avg_bw_decision >= 4 and avg_bw_decision < 8) {
        //     const auto ReductionFactor = 3;
        //     exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
        //         q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        // }
        // else if (avg_bw_decision >= 8) {
        //     const auto ReductionFactor = 2;
        //     exp_wrapper<Input, Huff, Dict, Magnitude, ReductionFactor>(
        //         q, len, cb, cb_len, dummy_nchunk, avg_bw_decision);
        // }
    }

    delete[] q, cb;
}

int main(int argc, char** argv)
{
    string dtype;
    if (argc < 4)
        dtype = string("uint16");
    else
        dtype = string(argv[2]);

    // if (dtype == "uint8") {  //
    //     // submain<uint8_t, ulli>(argc, argv);
    //     submain<uint8_t, /*huff enc*/ uint32_t, /*huff cb*/ uint32_t>(argc, argv);
    // }
    if (dtype == "uint16") {  //
        // submain<uint16_t, ulli>(argc, argv);
        submain<uint16_t, /*huff enc*/ uint32_t, /*huff cb*/ uint32_t>(argc, argv);
    }

    return 0;
}
